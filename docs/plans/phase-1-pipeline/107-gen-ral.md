# Task 107: UVM RAL + HAL + C 드라이버 생성기 (GenRAL)

> **목표**: 포트 기반 UVM reg_block + HAL 헤더 + C 드라이버 생성 (신규)
> **예상 시간**: 2일
> **파일**: `lib/Target/GenRAL.cpp` (신규)
> **TDD**: RED → GREEN → REFACTOR

---

## 현재 상태

- 신규: GenRAL.cpp 없음

---

## Step 1: RED — GenRAL 미존재 (5분)

**Goal**: GenRAL 호출 시 산출물 없음 확인

**Run**:
```bash
hirct-gen rtl/plat/src/s5/design/Fadu_K2_S5_LevelGateway.v
ls output/plat/src/s5/design/Fadu_K2_S5_LevelGateway/ral/ 2>/dev/null || echo "no ral"
```

> **Implementation Note**: 개발 중 개별 emitter 테스트 시 `--only` 필터 사용:
> `hirct-gen rtl/plat/src/s5/design/Fadu_K2_S5_LevelGateway.v --only ral`

**Expect**:
```
no ral
```

---

## Step 2: GREEN — 최소 reg_block 생성 (3시간)

**Goal**: 파이프라인의 IR 레지스터 판정 로직(ModuleAnalyzer.detectRegisters())을 통해 자동 선별, uvm_reg_block 상속 클래스 생성

> **Note**: test/Target/GenRAL/basic-register.mlir에 최소 레지스터 IR을 내장하여 반드시 1회 검증

**Run**:
```bash
# lit 테스트로 기본 검증
cmake --build build
llvm-lit test/Target/GenRAL/basic-register.mlir
# 실제 모듈로 산출물 확인
hirct-gen <레지스터 포함 모듈>.v
ls output/<path>/<module>/ral/
grep "uvm_reg" output/<path>/<module>/ral/*.sv | head -10
```

**Expect**:
```
class xxx_reg_block extends uvm_reg_block
```

---

## Step 3: 포트→레지스터 매핑 (2시간)

**Goal**: 입력/출력 포트를 reg_field로 매핑 (간단 매핑)

**Run**:
```bash
hirct-gen <레지스터 포함 모듈>.v
# reg_field 선언 확인
grep "uvm_reg_field\|add_hdl_path" output/<path>/<module>/ral/*.sv | head -15
```

**Expect**:
```
포트별 uvm_reg_field
```

---

## Step 4: Gate — UVM 컴파일 또는 lint (30분)

**Goal**: vcs -sverilog + UVM 또는 verilator로 문법 검증

**Run**:
```bash
hirct-gen <레지스터 포함 모듈>.v
# UVM_HOME 설정 시
vcs -sverilog +incdir+$UVM_HOME/src output/<path>/<module>/ral/*.sv 2>&1 | tail -5
# 또는
verilator --lint-only -Wall output/<path>/<module>/ral/*.sv 2>&1 | tail -5
```

**Expect**:
```
컴파일/lint 통과 (UVM 없으면 verilator만)
```

---

## Step 5: HAL 헤더 생성 (2시간)

**Goal**: 레지스터 매핑에서 C HAL 헤더(레지스터 주소, 비트 필드 매크로) 자동 생성

**출력 파일**: `ral/<module>_hal.h`

**생성 내용**:
```c
// AUTO-GENERATED by hirct-gen — DO NOT EDIT
#ifndef <MODULE>_HAL_H
#define <MODULE>_HAL_H

#include <stdint.h>

// Register addresses
#define <MODULE>_REG_CTRL_ADDR  0x00
#define <MODULE>_REG_STATUS_ADDR 0x04

// Bit field macros
#define <MODULE>_CTRL_EN_BIT    0
#define <MODULE>_CTRL_EN_MASK   (1U << 0)

// Read/Write helpers
static inline uint32_t <module>_read_reg(volatile void* base, uint32_t offset) {
    return *(volatile uint32_t*)((uint8_t*)base + offset);
}
static inline void <module>_write_reg(volatile void* base, uint32_t offset, uint32_t val) {
    *(volatile uint32_t*)((uint8_t*)base + offset) = val;
}
#endif
```

**Run**:
```bash
hirct-gen <레지스터 포함 모듈>.v
ls output/<path>/<module>/ral/*_hal.h
grep "#define.*ADDR\|static inline" output/<path>/<module>/ral/*_hal.h | head -10
```

**Expect**:
```
레지스터 주소 매크로 + read/write 헬퍼 함수 존재
```

---

## Step 6: C 드라이버 생성 (1시간)

**Goal**: HAL 헤더를 사용하는 기본 C 드라이버 소스 자동 생성

**출력 파일**: `ral/<module>_driver.c`

**생성 내용**:
```c
// AUTO-GENERATED by hirct-gen — DO NOT EDIT
#include "<module>_hal.h"

void <module>_init(volatile void* base) {
    // 초기화 시퀀스 (레지스터별 기본값 설정)
    <module>_write_reg(base, <MODULE>_REG_CTRL_ADDR, 0x0);
}
```

**Run**:
```bash
hirct-gen <레지스터 포함 모듈>.v
g++ -std=c++17 -c -I output/<path>/<module>/ral output/<path>/<module>/ral/*_driver.c
echo "Exit: $?"
```

**Expect**:
```
Exit: 0
```

---

## Step 7: 커밋

**Goal**: GenRAL 전체 기능 완료 (UVM RAL + HAL + C Driver)

**Run**:
```bash
git add lib/Target/GenRAL.cpp include/hirct/Target/GenRAL.h lib/Target/CMakeLists.txt
git commit -m "feat(phase-1): GenRAL - UVM reg_block + HAL header + C driver generator"
```

---

## ModuleAnalyzer 변경 사항

**신규 구현**: `RegisterDetectionResult detectRegisters() const`
- 판정 기준: IR 패턴(seq.firreg/seq.compreg) — Phase 1 유일 기준
- 결과에 detection 방법과 근거를 포함

---

## 레지스터 존재 판정 기준

GenRAL은 다음 조건 중 하나를 만족하는 모듈에 대해서만 산출물을 생성한다:

**판정 기준 (Phase 1 — 단순화)**:

Phase 1에서는 IR 패턴만으로 판정한다. 어노테이션과 포트 이름 휴리스틱은 Phase 2에서 실패 분석 후 도입한다.

1. **IR 레지스터 패턴 (Phase 1 유일 기준)**: `seq.firreg` 또는 `seq.compreg` operation이 존재하는 경우 → 레지스터 모듈로 판정
2. **명시적 어노테이션 (Phase 2 추가 예정)**: IR에 `hw.hierpath` 또는 사용자 정의 attribute로 레지스터 블록이 표시된 경우
3. **포트 이름 휴리스틱 (Phase 2 추가 예정)**: `addr`, `wdata`, `rdata`, `wen`, `ren` 등 CSR 접근 패턴의 포트가 존재하는 경우

**Phase 2 확장 계획:**
- 기준 2~3은 Phase 2에서 실제 실패 분석 결과를 바탕으로 도입한다
- 휴리스틱 판정 시 verbose 로그 경고, report.json에 판정 방법 기록, false positive 방지 정책은 Phase 2에서 설계

**미지원 시 동작:**

- 위 조건을 만족하지 않는 모듈: GenRAL 스킵
- report.json에 `"ral": "skipped"` + 스킵 사유 기록
- exit code 0 유지 (에러가 아닌 정상 스킵)

---

## 완료 체크리스트

- [ ] GenRAL.cpp 생성
- [ ] uvm_reg_block 상속 클래스 (`_ral.sv`)
- [ ] 포트→reg_field 매핑
- [ ] UVM compile 또는 verilator lint PASS
- [ ] HAL 헤더 (`_hal.h`) 생성: 주소 매크로 + read/write 헬퍼
- [ ] C 드라이버 (`_driver.c`) 생성: HAL 기반 초기화 함수
- [ ] `g++ -c _driver.c` → exit 0
- [ ] 레지스터 없는 모듈 → ral/ 미생성 + meta.json에 `"ral": "skipped", "detection": "none"` 기록
- [ ] 레지스터 판정 기준이 정확히 동작 (false positive/negative 없음)
- [ ] 커밋 완료
- [ ] `test/Target/GenRAL/` lit 테스트 최소 1개 PASS
