#include "hirct/Target/GenModel.h"

#include <cerrno>
#include <cstring>
#include <fstream>
#include <iostream>
#include <sys/stat.h>

namespace hirct {

static constexpr const char *AUTO_GENERATED_HEADER =
    "// AUTO-GENERATED by hirct-gen \xe2\x80\x94 DO NOT EDIT\n";

GenModel::GenModel(const ModuleAnalyzer &analyzer) : analyzer_(analyzer) {}

std::string GenModel::cpp_type_for_width(int width) const {
  if (width == 1)
    return "bool";
  if (width <= 8)
    return "uint8_t";
  if (width <= 16)
    return "uint16_t";
  if (width <= 32)
    return "uint32_t";
  if (width <= 64)
    return "uint64_t";
  return "";
}

bool GenModel::emit(const std::string &output_dir) {
  if (!analyzer_.is_valid()) {
    std::cerr << "GenModel: analyzer is not valid\n";
    return false;
  }

  std::string cmodel_dir = output_dir + "/cmodel";
  if (mkdir(cmodel_dir.c_str(), 0755) != 0 && errno != EEXIST) {
    std::cerr << "GenModel: cannot create directory: " << cmodel_dir << ": "
              << strerror(errno) << "\n";
    return false;
  }

  if (!emit_header(cmodel_dir)) {
    return false;
  }
  if (!emit_impl(cmodel_dir)) {
    return false;
  }
  return true;
}

bool GenModel::emit_header(const std::string &dir) {
  std::string name = analyzer_.module_name();
  std::string path = dir + "/" + name + ".h";

  std::ofstream ofs(path);
  if (!ofs) {
    std::cerr << "GenModel: cannot open " << path << "\n";
    return false;
  }

  std::string guard = "CMODEL_" + name + "_H";
  for (auto &c : guard) {
    c = static_cast<char>(toupper(static_cast<unsigned char>(c)));
  }

  ofs << AUTO_GENERATED_HEADER;
  ofs << "#ifndef " << guard << "\n";
  ofs << "#define " << guard << "\n\n";
  ofs << "#include <cstdint>\n\n";
  ofs << "class " << name << " {\n";
  ofs << "public:\n";

  // Port members
  for (const auto &p : analyzer_.ports()) {
    std::string ctype = cpp_type_for_width(p.width);
    if (ctype.empty()) {
      std::cerr << "GenModel: unsupported width " << p.width << " for port "
                << p.name << "\n";
      return false;
    }
    ofs << "  " << ctype << " " << p.name << ";\n";
  }

  ofs << "\n";
  ofs << "  void do_reset();\n";
  ofs << "  void step();\n";
  ofs << "  void eval_comb();\n";
  ofs << "};\n\n";
  ofs << "#endif // " << guard << "\n";

  return true;
}

bool GenModel::emit_impl(const std::string &dir) {
  std::string name = analyzer_.module_name();
  std::string path = dir + "/" + name + ".cpp";

  std::ofstream ofs(path);
  if (!ofs) {
    std::cerr << "GenModel: cannot open " << path << "\n";
    return false;
  }

  ofs << AUTO_GENERATED_HEADER;
  ofs << "#include \"" << name << ".h\"\n\n";

  // eval_comb: sets outputs to 0
  ofs << "void " << name << "::eval_comb()\n{\n";
  for (const auto &p : analyzer_.output_ports()) {
    ofs << "  " << p.name << " = 0;\n";
  }
  ofs << "}\n\n";

  // step: calls eval_comb
  ofs << "void " << name << "::step()\n{\n";
  ofs << "  eval_comb();\n";
  ofs << "}\n\n";

  // do_reset: zeroes everything
  ofs << "void " << name << "::do_reset()\n{\n";
  for (const auto &p : analyzer_.ports()) {
    ofs << "  " << p.name << " = 0;\n";
  }
  ofs << "}\n";

  return true;
}

} // namespace hirct
